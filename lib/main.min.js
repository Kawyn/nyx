const BACKGROUND_COLOR = [202 / 255, 168 / 255, 245 / 255], FRAGMENT_TYPE = "nyx-fragment", FRAGMENT_DEFAULT = `
    precision mediump float;
    
    uniform vec2 u_resolution;

    void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution;
        gl_FragColor = vec4(uv.x, uv.y, 0., 1.);
    }
`; class Nyx {
    constructor (e, f = 100, g = null) {
        e || (e = "default"), g |= f, this.uniforms.set("u_resolution", [f, g]), this.uniforms.set("u_start_time", new Date().getTime()); let c = document.createElement("canvas"); c.name = e, c.width = f, c.height = g, document.body.appendChild(c, document.body); let a = c.getContext("webgl"); if (!a) throw "[NYX] CONSTRUCTOR ERROR: your browser does not support WebGL"; a.clearColor(BACKGROUND_COLOR[0], BACKGROUND_COLOR[1], BACKGROUND_COLOR[2], 1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT); let b = a.createProgram(), h = a.createShader(a.VERTEX_SHADER), d = a.createShader(a.FRAGMENT_SHADER); if (a.shaderSource(d, document.querySelector('script[type="' + 'nyx-fragment"][name="' + e + '"]')?.textContent || FRAGMENT_DEFAULT), a.shaderSource(h, `
            attribute vec2 a_position;

            void main() {
                gl_Position = vec4(a_position, 0., 1.);
            }
        `), a.compileShader(h), a.compileShader(d), !a.getShaderParameter(d, a.COMPILE_STATUS)) throw "[NYX] FRAGMENT SHADER " + a.getShaderInfoLog(d); a.attachShader(b, h), a.attachShader(b, d), a.linkProgram(b), a.useProgram(b); let k = a.createBuffer(); a.bindBuffer(a.ARRAY_BUFFER, k), a.bufferData(a.ARRAY_BUFFER, new Float32Array([-1, 1, 0, -1, -1, 0, 1, -1, -0, 1, 1, -0,]), a.STATIC_DRAW); let l = a.createBuffer(); a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, l), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([3, 2, 1, 3, 1, 0]), a.STATIC_DRAW); let j = a.getAttribLocation(b, "a_position"); for (let i in a.vertexAttribPointer(j, 3, a.FLOAT, a.FALSE, 0, 0), a.enableVertexAttribArray(j), this.uniforms) "function" != typeof this.uniforms[i] && (this.uniforms[i].location = a.getUniformLocation(b, i)); this.ctx = a, this.canvas = c, this.program = b, this.refresh(), this.settings.refresh && setInterval(this.refresh, this.settings.interval)
    } settings = { refresh: !0, interval: 16.667 }; uniforms = { u_start_time: { type: "1f", value: 0 }, u_time: { type: "1f", value: () => (new Date().getTime() - this.uniforms.u_start_time.value) / 1e3 }, u_resolution: { type: "2f", value: [0, 0] }, new: (a, b, c) => (this.uniforms[a] = { type: b, value: c }, this.ctx && (this.uniforms[a].location = this.ctx.getUniformLocation(this.program, a)), this.uniforms), set: (a, b) => { if (!this.uniforms.hasOwnProperty(a)) throw "[NYX] UNIFORM ERROR: " + a + " is undefined"; return this.uniforms[a].value = b, this.uniforms } }; refresh = () => { let b = this.ctx; for (let d in this.uniforms) { if ("function" == typeof this.uniforms[d]) continue; let a = this.uniforms[d], c = "function" == typeof a.value ? a.value() : a.value; switch (a.type) { case "1f": b.uniform1f(a.location, c); break; case "2f": b.uniform2fv(a.location, c); break; case "3f": b.uniform3fv(a.location, c); break; case "4f": b.uniform4fv(a.location, c); break; case "1i": b.uniform1i(a.location, c); break; case "2i": b.uniform2iv(a.location, c); break; case "3i": b.uniform3iv(a.location, c); break; case "4i": b.uniform4iv(a.location, c); break; case "2m": b.uniformMatrix2fv(a.location, !1, c); break; case "3m": b.uniformMatrix3fv(a.location, !1, c); break; case "4m": b.uniformMatrix4fv(a.location, !1, c); break; default: console.warn("[NYX] UNIFORM ERROR: " + a.type + " is not valid unifrom type in webctx.") } } b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0) }
} const Nyks = Nyx